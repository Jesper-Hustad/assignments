## OBL3-OS
# Synchronisation

## 1 About synchronisation
### 1. 
*The principle of process isolation in an operating system means that processes must not have access
to the address spaces of other processes or the kernel. However, processes also need to communicate.*
#### a) Give an example of such communication.
Shared memory fits the bill exactly for this kind of job, but message passing which works in a form of a queue are also common.

#### b) How does this communication work?
For the program it's just a memory adress generated by the os where it can store and retrieve data. Message passing is controlled much more heavily by the OS so you can call send or recieve and the os handles it all.


#### c) What problems can result from inter-process communication?
Multiple processes accessing data stored in a location can be tought of like a type of database, so just like in databaes the same problems arise with inter-process communicaton. The termonology used within OS is:
- **Starvation:**
That one process is working with data and doesn't let others access it. For example if a program waits for user input while attached to a memory segment it can't be accessed by any other process for that entire time.

- **Deadlock:** Same as in Db, two processes waiting for eachother to complete before they can continue.

- **Data inconsistency** Programs overwriting changes, not being up to date with newest data and therefore getting wrong results. Like a program taking the sum of some data, but letting data be changed while doing so will cause the sum to be incorrect.


### 2. 
*What is a critical region? Can a process be interrupted while in a critical region? Explain.*
Locks shared values and realeses them when done so prevents data inconsistency and starvation (because only one critical section can run on a piece of data at a time).

A higher level interupt can still occur, this way we don't give the power for a program to run however it wants by just saying it's critical.

### 3. 
*Explain the difference between busy waiting (polling) versus blocking (wait/signal) in the context of a process trying to get access to a critical section.*

Blocking would mean the process doesn't continue executing when trying to access a critical section. A process which must have that data to continue would use this.

Polling (similar to asynchronous used in many other languages) continues doing other stuff while waiting for the critical section. For example if we want to copy some data we could continue copying other stuff while waiting for the critical section to finish.


### 4. 
*What is a race condition? Give a real-world example.*

Two processes accessing data without blocking can lead to a race condition because they both rely on same data to be accurate.

```
get the value x

set x as one plus x
```
If this program is sharing the x variable and run simultaneously they could both get x and then work with an old value for x


### 5. 
*What is a spin-lock, and why and where is it used?*

A simple form of "blocking" from question 3 that can be looked as a `while true` loop where the break condition is the lock being released.


### 6.
*List the issues involved with thread synchronisation in multi-core architectures. Two lock algorithms
are MCS and RCU (read-copy-update). Describe the problems they attempt to address. What hardware mechanism lies at the heart of each*

MCS is an optimized version of spin-lock that stores that status in a queue structure.

RCU stores multiple versions of objects so that read is easier and faster.

As there are more threads the wasted time increases with waiting for locks to be realesed. So smart solutions that store versions in cache allow faster reads. 


## 2 Deadlocks

### 1. 
*What is the difference between resource starvation and a deadlock?*
<!-- Resource starvation only requires one process to fuck up, while a deadlock requires two. No, but seriously  -->
Deadlock like described earlier is two processes waiting for eachother to complete before they can continue. So in a deadlock both programs are causing resource starvation for the other.

### 2. 
*What are the four necessary conditions for a deadlock? Which of these are inherent properties of an
operating system?*

Mutual exclusion, no preemption (not being able to cancel a process) and blocking are inherent properties of an operating system

While the circular wait is a function of what the program requires.

### 3. 
*How does an operating system detect a deadlock state? What information does it have available to
make this assessment?*

If the os has a log of resource allocation and sees two processes stuck it would be a strong indication of a deadlock.

## 3 Scheduling


### 1. 
*Uniprocessor scheduling*


#### a) When is first-in-first-out (FIFO) scheduling optimal in terms of average response time? Why?

It has low overhead because it just adds processes to the que in the same order they arrive. so for many very short tasks it's optimal.



#### b) Describe how Multilevel feedback queues (MFQ) combines first-in-first-out, shortest job first, and round robin scheduling in an attempt at a fair and efficient scheduler. What (if any) are its shortcomings?

Round robin doesn't use any data analyzing to choose which process gets time, so MFQ maintains low overhead and doesn't allow starvation.

It may be one of the positives, but simultaneously a negative that there is no data analyzing to make it more efficient. 



### 2.
*Multi-core scheduling*

#### a) Similar to thread synchronisation, a uniprocessor scheduler running on a multi-core system can be very inefficient. Explain why (there are three main reasons). Use MFQ as an example.

Processes in spinlock are in MFQ given time, cache can be slowed due to many threads and processes. Cache can be filled so the benefits are lost.


#### b) Explain the concept of work-stealing.

In many core CPUs many cores will lie idle and therefore have time to "steal" some tasks to increase performance. 




